<div id="raycast-canvas" width="640" height="400"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<script>
  const MAX_BRIGHTNESS = 255; // maximum brightness for walls
  const MIN_BRIGHTNESS = 20;// minimum brightness for walls
  const FIELD_OF_VIEW = Math.PI / 2; // 90 degrees field of view
  const FADE_POINT = 15; // distance at which brightness fades to minimum

  class Point {
    //default is cartesian
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    nextLocation(angle, distance){
      //precondition: angle is in radians, magnitude is positive
      //postconditions:
      // state of this point is unchanged
      //returns a new point <magnitude> distance away from the current point in the direction of <angle>
        if (distance < 0) {
          throw new Error("Distance must be non-negative");
        }
        return new Point(
          this.polarToCartesian(this.x, cos, angle, distance),
          this.polarToCartesian(this.y, sin, angle, distance)
        );
    }
    
    polarToCartesian(position, func, angle, distance) {
      return position+ func(angle) * distance;
  }
}

let player = {};
let walls = [];

class Wall {
  constructor(x1, y1, x2, y2, color = null) {
    this.start = new Point(x1, y1);
    this.end = new Point(x2, y2); 
    this.color = color;
  }
}

function setup() {
  let canvas = createCanvas(640, 400);
  canvas.parent("raycast-canvas"); // attach to canvas tag
  noStroke();
  walls = [
    new Wall(1, 1, 58, 1), // top wall
    new Wall(40, 30,5,10, 'red'), // squiggle one
    new Wall(5,10, 70,30, 'red'),// squiggle two
    new Wall(58, 1, 58, 58), // right wall
    new Wall(58, 58, 1, 58), // bottom wall
    new Wall(1, 58, 1, 1), // left wall
  ];
  player = {position: new Point(4.5, 4.5), angle: 0 };
  }

function getRayAngle(angle, fov,increment, width){
  return angle - fov / 2 + (increment / width) * fov;
}

function drawMap2D(fov) {
  push();
  scale(10); // zoom in
  stroke(MAX_BRIGHTNESS);
  for (let wall of walls) {
    //law of demeter smell
    line(wall.start.x, wall.start.y, wall.end.x, wall.end.y);
  }
  fill('red');
  ellipse(player.x, player.y, 0.1);

  // draw rays
  stroke(0, MAX_BRIGHTNESS, 0, 100);
  for (let i = 0; i < width; i += 20) { // thinner density for debugging
    const rayAngle = getRayAngle(player.angle, fov, i, width);
    let {dist} = castRay(rayAngle);
    hit = player.position.nextLocation(rayAngle, dist);
    line(player.position.x, player.position.y, hit.x, hit.y);
  }
  pop();
}

  
function draw() {
  background(0);

  for (let i = 0; i < width; i++) {
    const rayAngle = getRayAngle(player.angle, FIELD_OF_VIEW, i, width);
    let {dist} = castRay(rayAngle);
    let correctedDist = dist * cos(rayAngle - player.angle);
    let wallHeight = height / (correctedDist + 0.5); // height of the wall based on distance
    let brightness = max(MIN_BRIGHTNESS, MAX_BRIGHTNESS - correctedDist * FADE_POINT);
    fill(0, brightness, 0);
    rect(i, height / 2 - wallHeight / 2, 1, wallHeight);
  }
  //drawMap2D(FIELD_OF_VIEW);
  player.angle += 0.01; // rotate player for demonstration
}

function castRay(angle) {
  let rayDir = { x: cos(angle), y: sin(angle) };
  let origin = player.position;
  let closest = null;
  let color = null;

  for (let wall of walls) {
    let hit = rayIntersectsWall(origin, rayDir, wall);
        if (hit) {
      // Uncomment this line to print wall hits
//          console.log(`Hit wall (${wall.start.x},${wall.start.y})â€“(${wall.end.x},${wall.end.y}) at distance ${hit.distance}`);
    }
    if (hit && (!closest || hit.distance < closest.distance)) {
      closest = hit;
    }
  }
  if (closest) {
    return {dist: closest.distance, color};
  }

  return {dist: 1000, color};
}

function rayIntersectsWall(rayOrigin, rayDir, wall) {
  const { start, end } = wall;

  const x3 = rayOrigin.x;
  const y3 = rayOrigin.y;
  const x4 = rayOrigin.x + rayDir.x;
  const y4 = rayOrigin.y + rayDir.y;

    const denom = (start.x - end.x) * (y3 - y4) - (start.y - end.y) * (x3 - x4);
  if (abs(denom) < 0.00001) return null; // parallel or identical

  const t = ((start.x - x3) * (y3 - y4) - (start.y - y3) * (x3 - x4)) / denom;
    const u = -((start.x - end.x) * (start.y - y3) - (start.y - end.y) * (start.x - x3)) / denom;

  if (t < 0 || t > 1 || u < 0) return null;

    const intersectionX = start.x + t * (end.x - start.x);
    const intersectionY = start.y + t * (end.y - start.y);
    const distance = dist(x3, y3, intersectionX, intersectionY); //TODO: look up dist function

  return { x: intersectionX, y: intersectionY, distance };
}
</script>
