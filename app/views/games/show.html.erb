<div id="raycast-canvas" width="640" height="400"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
<script>
  const MAX_BRIGHTNESS = 255; // maximum brightness for walls
  const MIN_BRIGHTNESS = 20;// minimum brightness for walls
  const FIELD_OF_VIEW = Math.PI / 2; // 90 degrees field of view
  const FADE_POINT = 15; // distance at which brightness fades to minimum
  
  let player = {};
  let walls = [];

  function setup() {
    let canvas = createCanvas(640, 400);
    canvas.parent("raycast-canvas"); 
    noStroke();
    topWall = new Wall(1, 1, 58, 1);
    rightWall = new Wall(58, 1, 58, 58);
    bottomWall = new Wall(58, 58, 1, 58);
    leftWall = new Wall(1, 58, 1, 1);

    walls = [
      topWall,
      new Wall(40, 30, 5,10, 'red'), 
      new Wall(5, 10, 70,30, 'red'),
      rightWall, 
      bottomWall, 
      leftWall, 
    ];

    player = new Player(4.5, 4.5, 0)
    player.draw2D();
  }

  class Wall {
    constructor(x1, y1, x2, y2, color = null) {
      this.start = new Point(x1, y1);
      this.end = new Point(x2, y2); 
      this.color = color;
    }

    draw2D() {
    stroke(this.color || MAX_BRIGHTNESS);
    strokeWeight(0.1);
    line(this.start.x, this.start.y, this.end.x, this.end.y);
    }
  }

  class Player {
    //angle is in radians
    constructor(x, y, angle) {
      this.position = new Point(x, y);
      this.angle = angle;
    }

    draw2D() {
      fillColor('red');
      noStroke();
      ellipse(this.position.x, this.position.y, 0.2);
    }
  }

  class Point {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    nextLocation(angle, distance){
        if (distance < 0) {
          throw new Error("Distance must be non-negative");
        }
      return new Point(
        this.x + cos(angle) * distance,
        this.y + sin(angle) * distance
      );
    }
  }

  function fillColor(color, brightness= MAX_BRIGHTNESS) {
    if (color === 'red') {
      fill(brightness, 0, 0);
    } else {
      fill(0, brightness, 0);
    }
  }

  function draw() {
    background(0);

    for (let i = 0; i < width; i++) {
      const rayAngle = getRayAngle(i);
      let {dist, color} = castRay(rayAngle);
      let correctedDist = removeFishEye(dist, rayAngle, player.angle);
      let wallHeight = calculateWallHeight(correctedDist);
      let brightness = calculateBrightness(correctedDist);
      fillColor(color, brightness);
      renderVerticalSlice(i, wallHeight);
    }
    drawMap2D(FIELD_OF_VIEW);
    player.angle += 0.01; // rotate player for demonstration
  }
  
  function getRayAngle(increment){
    return player.angle - FIELD_OF_VIEW / 2 + (increment / width) * FIELD_OF_VIEW;
  }

  function castRay(angle) {
    let rayDir = { x: cos(angle), y: sin(angle) };
    let origin = player.position;
    let closest = null;
    let color = null;

    for (let wall of walls) {
    
      let hit = rayIntersectsWall(origin, rayDir, wall);
      if (hit && (!closest || hit.distance < closest.distance)) {
        closest = hit;
        color = wall.color
      }
    }
    if (closest) {
      return {dist: closest.distance, color};
    }

    return {dist: 1000, color};
  }

  function removeFishEye(distance, angle, viewerAngle){
    return distance * cos(angle - viewerAngle);
  }

  function calculateWallHeight(distance) {
    if (distance <= 0) {
      return 2 * height;
    }
    return height / distance;
  }

  function calculateBrightness(distance) {
    return max(MIN_BRIGHTNESS, MAX_BRIGHTNESS - distance * FADE_POINT);
  }

  function renderVerticalSlice(fieldOfVisionXCoord, wallHeight){
    rect(fieldOfVisionXCoord, height / 2 - wallHeight / 2, 1, wallHeight);
  }

  function drawMap2D(fov) {
    push();
    scale(10);
    stroke(MAX_BRIGHTNESS);
    for (let wall of walls) {
      wall.draw2D();
    }

    fill('red');
    noStroke();
    player.draw2D();

    drawRays();

    pop();
  }

  function drawRays(){
    stroke(0, MAX_BRIGHTNESS, 0, 100);
    strokeWeight(0.05);
    let resolution = 20
    for (let i = 0; i < width; i += resolution) {
      const rayAngle = getRayAngle(i);
      let {dist} = castRay(rayAngle);
      hit = player.position.nextLocation(rayAngle, dist);
      line(player.position.x, player.position.y, hit.x, hit.y);
    }
  }

  
  function rayIntersectsWall(rayOrigin, rayDir, wall) {
    
    const { start, end } = wall;

    const x3 = rayOrigin.x;
    const y3 = rayOrigin.y;
    const x4 = rayOrigin.x + rayDir.x;
    const y4 = rayOrigin.y + rayDir.y;

    const determinant = (start.x - end.x) * (y3 - y4) - (start.y - end.y) * (x3 - x4);
    if (abs(determinant) < 0.00001) return null; // parallel or identical

    const wall_intersection = ((start.x - x3) * (y3 - y4) - (start.y - y3) * (x3 - x4)) / determinant;
    const ray_intersection = -((start.x - end.x) * (start.y - y3) - (start.y - end.y) * (start.x - x3)) / determinant;

    if (wall_intersection < 0 || wall_intersection > 1 || ray_intersection < 0) return null;

    const intersectionX = start.x + wall_intersection * (end.x - start.x);
    const intersectionY = start.y + wall_intersection * (end.y - start.y);
    const distance = dist(x3, y3, intersectionX, intersectionY); //TODO: look up dist function

    return { x: intersectionX, y: intersectionY, distance };
  }
</script>
